{"version":3,"sources":["../lib/core/dom.ts","../lib/core/math.ts","06-circles/src/resize.ts","../lib/core/wave.ts","../lib/core/step.ts","06-circles/src/entry.ts"],"names":[],"mappings":"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","file":"entry.59901d54.js","sourceRoot":"../src/lab","sourcesContent":["export const {\n  requestAnimationFrame: rAF,\n  cancelAnimationFrame: cAF,\n  devicePixelRatio: dpr,\n} = window;\n\nexport function el<T extends Element>(selectors: string): T {\n  const element = document.querySelector<T>(selectors);\n\n  if (!element) {\n    throw new Error(`Couldn't get \"${selectors}\" element`);\n  }\n\n  return element;\n}\n\ntype Listener<T extends Event> = (event: T) => void;\n\nexport function on<T extends Event>(type: string, listener: Listener<T>): void {\n  return window.addEventListener(type, listener as EventListener);\n}\n\nexport function off<T extends Event>(\n  type: string,\n  listener: Listener<T>,\n): void {\n  return window.removeEventListener(type, listener as EventListener);\n}\n","export const {\n  abs,\n  acos,\n  atan2,\n  ceil,\n  cos,\n  floor,\n  hypot,\n  max,\n  min,\n  PI: π,\n  pow,\n  round,\n  sin,\n  sqrt,\n} = Math;\nexport const ππ = π * 2;\nexport const { isFinite } = Number;\n\n/**\n * ## lerp\n * short for \"linear interpolate\" this function returns a number that is\n * interpolated between `a` and `b` by the ratio provided in `i` (e.g. if `i` is\n * 0 `a` is returned, if `i` is 1 `b` is returned)\n *\n * @export\n * @param {number} v0 the lower bound of the interpolation\n * @param {number} v1 the upper bound of the interpolation\n * @param {number} t the ratio by which to interpolate between `a` and `b`\n * @returns {number} a number that is interpolated between `a` and `b` by the\n * ratio provided in `i`\n */\nexport function lerp(v0: number, v1: number, t: number): number {\n  /**\n   * prefer precise method\n   * @see: https://github.com/mattdesl/lerp/blob/master/index.js\n   * @see: https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\n   */\n  return (1 - t) * v0 + t * v1;\n}\n\n/**\n * ## saw\n * this is a trigonometric function (like Math.sin, or Math.cos), it takes an\n * angle in radians and returns a value between -1 and 1, the \"shape\" of the\n * returned values follows a linear \"sawtooth\" pattern\n *\n * @export\n * @param {number} radians a value in radians (clamped between 0 and ππ)\n * @returns {number} a value between -1 and 1 for entry values between 0 and ππ\n */\nexport function saw(radians: number): number {\n  return (radians % ππ) / π - 1;\n}\n\n/**\n * ## tri\n * this is a trigonometric function (like Math.sin, or Math.cos), it takes an\n * angle in radians and returns a value between -1 and 1, the \"shape\" of the\n * returned values follows a linear \"triangle wave\" pattern\n *\n * @export\n * @param {number} radians a value in radians (clamped between 0 and ππ)\n * @returns {number} a value between -1 and 1 for entry values between 0 and ππ\n */\nexport function tri(radians: number): number {\n  return 1 - 2 * abs(saw(radians));\n}\n\n/**\n * ## toDegrees\n * takes an angle in radians and returns that angle in degrees\n *\n * @param {number} radians an angle, in radians\n * @return {number} that same angle, in degrees\n */\nexport function toDegrees(radians: number): number {\n  return (radians * 180) / π;\n}\n\n/**\n * ## toRadians\n * takes an angle in degrees and returns that angle in radians\n *\n * @param {number} degrees an angle, in degrees\n * @return {number} that same angle, in radians\n */\nexport function toRadians(degrees: number): number {\n  return (degrees * π) / 180;\n}\n","import { on } from '../../../lib/core/dom';\nimport { max } from '../../../lib/core/math';\n\nfunction next(multipleOf = 1, startingAt = 0) {\n  return startingAt % multipleOf !== 0\n    ? startingAt + (multipleOf - (startingAt % multipleOf))\n    : startingAt;\n}\n\nlet didResizeWindow = true;\non('resize', () => {\n  didResizeWindow = true;\n});\n\nexport function shouldResize() {\n  return didResizeWindow;\n}\n\nexport function resize(\n  canvas: HTMLCanvasElement,\n  container: HTMLElement,\n  scale = 1,\n): void {\n  if (!didResizeWindow) {\n    return;\n  }\n\n  didResizeWindow = false;\n\n  const { devicePixelRatio: dpr } = window;\n  const { clientHeight: h, clientWidth: w } = container;\n\n  const width = next(scale, w);\n  const height = next(scale, h);\n\n  canvas.width = (width * dpr) / scale;\n  canvas.height = (height * dpr) / scale;\n\n  // canvas.style.width = `${width}px`;\n  // canvas.style.height = `${height}px`;\n  canvas.style.transform = `scale(${max(w / canvas.width, h / canvas.height)})`;\n}\n","import { cos, saw, sin, tri, ππ } from './math';\n\nexport type TrigFunction = (radians: number) => number;\nexport type WaveFunction = (timestamp: number) => number;\n\n/**\n * ## wave\n * this utility function uses the provided trigonometric function to create a\n * wave function that takes a timestamp in milliseconds (optionally offset by\n * `o`) and that returns a value between `min` and `max` for the period `p`\n *\n * @export\n * @param {TrigFunction} fn the function to generate the wave (takes a value in\n * radians and returns a value between -1 and 1 at some interval)\n * @param {number} [p=1000] the period for this wave (in milliseconds)\n * @param {*} [min=-1] the minimum value for the generated wave\n * @param {number} [max=1] the maximum value for the generated wave\n * @param {number} [o=0] an optional offset (in milliseconds) at which to start\n * the wave\n * @returns {WaveFunction} a wave function that takes a timestamp in\n * milliseconds (optionally offset by `o`) and returns a value between `min` and\n * `max` for the period `p`\n */\nexport function wave(\n  fn: TrigFunction,\n  p = 1000,\n  min = -1,\n  max = 1,\n  o = 0,\n): WaveFunction {\n  /**\n   * peak amplitude (not peak-to-peak amplitude)\n   * @see https://en.wikipedia.org/wiki/Amplitude\n   */\n  const amp = (max - min) / 2;\n\n  /**\n   * radians per period (angular frequency)\n   * @see https://en.wikipedia.org/wiki/Angular_frequency\n   */\n  const rpp = ππ / p;\n\n  return (t: number) => {\n    const ots = o + t; // offset timestamp\n    return amp * (1 + fn(ots * rpp)) + min;\n  };\n}\n\ntype CurriedWaveFunction = (\n  p?: number,\n  min?: number,\n  max?: number,\n  o?: number,\n) => WaveFunction;\n\nexport const [cosWave, sawWave, sinWave, triWave]: CurriedWaveFunction[] = [\n  (p = 1000, min = -1, max = 1, o = 0) => wave(cos, p, min, max, o),\n  (p = 1000, min = -1, max = 1, o = 0) => wave(saw, p, min, max, o),\n  (p = 1000, min = -1, max = 1, o = 0) => wave(sin, p, min, max, o),\n  (p = 1000, min = -1, max = 1, o = 0) => wave(tri, p, min, max, o),\n];\n","import { cos, floor, saw, sin, tri } from './math';\nimport { wave, TrigFunction, WaveFunction } from './wave';\n\n/**\n * ## step\n * this utility function returns a step function (like a integer-only wave\n * function) that takes a timestamp (optionally offset by `o`) and returns an\n * integer value between `min` and `max` for the period `p`\n *\n * @export\n * @param {TrigFunction} fn the function to generate the stepped wave (takes a\n * value in radians and returns a value between -1 and 1 at some interval)\n * @param {number} [p=1000] the period for this stepped wave (in milliseconds)\n * @param {*} [min=-1] the minimum value for the generated stepped wave\n * @param {number} [max=1] the maximum value for the generated stepped wave\n * @param {number} [o=0] an optional offset (in milliseconds) at which to start\n * the stepped wave\n * @returns {WaveFunction} a stepped (integer-only) wave function that takes a\n * timestamp (optionally offset by `o`) and returns an integer value between\n * `min` and `max` for the period `p`\n */\nexport function step(\n  fn: TrigFunction,\n  p = 1000,\n  min = -1,\n  max = 1,\n  o = 0,\n): WaveFunction {\n  const waveFn = wave(fn, p, min, max, o);\n  return (t: number) => floor(waveFn(t));\n}\n\nexport const cosStep = (...args: number[]) => step(cos, ...args);\nexport const sawStep = (...args: number[]) => step(saw, ...args);\nexport const sinStep = (...args: number[]) => step(sin, ...args);\nexport const triStep = (...args: number[]) => step(tri, ...args);\n","import './style.css';\n\nimport { el, rAF } from '../../../lib/core/dom';\nimport { shouldResize, resize } from './resize';\nimport { sinStep } from '../../../lib/core/step';\n\nconst c = el('canvas') as HTMLCanvasElement;\nconst m = el('main') as HTMLElement;\nconst ctx = c.getContext('2d') as CanvasRenderingContext2D;\n\nconst channels = 4;\nfunction index(w: number) {\n  return (x: number, y: number) => channels * (y * w + x);\n}\n\ninterface Color {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n}\nfunction pixel(\n  getIndex: (x: number, y: number) => number,\n  data: Uint8ClampedArray,\n) {\n  return (x: number, y: number, { r, g, b, a }: Color) => {\n    const i = getIndex(x, y);\n    // tslint:disable no-bitwise\n    data[i + 0] |= r;\n    data[i + 1] |= g;\n    data[i + 2] |= b;\n    data[i + 3] |= a;\n    // tslint:enable no-bitwise\n  };\n}\n\nfunction renderCircle(\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  r: number,\n  col = {\n    r: 255,\n    g: 255,\n    b: 255,\n    a: 255,\n  },\n) {\n  const {\n    canvas: { width: w, height: h },\n  } = context;\n  const imageData = context.getImageData(0, 0, w, h);\n  const { data } = imageData;\n\n  const render = pixel(index(w), data);\n\n  const d = r * 2;\n\n  let i = r - 1;\n  let j = 0;\n  let di = 1;\n  let dj = 1;\n  let over = di - d;\n\n  while (i >= j) {\n    render(i + x, j + y, col);\n    render(j + x, i + y, col);\n\n    render(-i + x, j + y, col);\n    render(-j + x, i + y, col);\n\n    render(-i + x, -j + y, col);\n    render(-j + x, -i + y, col);\n\n    render(i + x, -j + y, col);\n    render(j + x, -i + y, col);\n\n    if (over <= 0) {\n      j++;\n      over += dj;\n      dj += 2;\n    }\n\n    if (over > 0) {\n      i--;\n      di += 2;\n      over += -d + di;\n    }\n  }\n\n  context.putImageData(imageData, 0, 0);\n}\n\nconst duration = 11000;\nconst circles = [\n  {\n    r: 255,\n    g: 0,\n    b: 0,\n    a: 255,\n  },\n  {\n    r: 0,\n    g: 255,\n    b: 255,\n    a: 255,\n  },\n  {\n    r: 0,\n    g: 255,\n    b: 0,\n    a: 255,\n  },\n  {\n    r: 255,\n    g: 0,\n    b: 255,\n    a: 255,\n  },\n  {\n    r: 0,\n    g: 0,\n    b: 255,\n    a: 255,\n  },\n  {\n    r: 255,\n    g: 255,\n    b: 0,\n    a: 255,\n  },\n].map((color, i, { length }) => ({\n  color,\n  radius: sinStep(duration, 1, 31, (duration / 2) * (i / length)),\n}));\n\nrAF(function tick(time: DOMHighResTimeStamp) {\n  rAF(tick);\n\n  if (shouldResize()) {\n    resize(c, m, 20);\n  }\n\n  ctx.fillStyle = '#000';\n  ctx.fillRect(0, 0, c.width, c.height);\n\n  circles.forEach(({ color, radius }) => {\n    renderCircle(ctx, c.width / 2, c.height / 2, radius(time), color);\n  });\n\n  renderCircle(ctx, c.width / 2, c.height / 2, 33, circles[0].color);\n  renderCircle(ctx, c.width / 2, c.height / 2, 33, circles[2].color);\n  renderCircle(ctx, c.width / 2, c.height / 2, 33, circles[4].color);\n});\n"]}