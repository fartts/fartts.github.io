{"version":3,"sources":["../lib/core/math.ts","19-ponds/src/dom-utils.ts","19-ponds/src/drawing-utils.ts","19-ponds/src/map.ts","19-ponds/src/entry.ts"],"names":[],"mappings":"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","file":"entry.43018996.js","sourceRoot":"../src/lab","sourcesContent":["export const {\n  abs,\n  acos,\n  atan2,\n  ceil,\n  cos,\n  floor,\n  hypot,\n  max,\n  min,\n  PI: π,\n  pow,\n  random,\n  round,\n  sin,\n  sqrt,\n} = Math;\nexport const ππ = π * 2;\nexport const { isFinite } = Number;\n\n/**\n * ## lerp\n * short for \"linear interpolate\" this function returns a number that is\n * interpolated between `a` and `b` by the ratio provided in `i` (e.g. if `i` is\n * 0 `a` is returned, if `i` is 1 `b` is returned)\n *\n * @export\n * @param {number} v0 the lower bound of the interpolation\n * @param {number} v1 the upper bound of the interpolation\n * @param {number} t the ratio by which to interpolate between `a` and `b`\n * @returns {number} a number that is interpolated between `a` and `b` by the\n * ratio provided in `i`\n */\nexport function lerp(v0: number, v1: number, t: number): number {\n  /**\n   * prefer precise method\n   * @see: https://github.com/mattdesl/lerp/blob/master/index.js\n   * @see: https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\n   */\n  return (1 - t) * v0 + t * v1;\n}\n\n/**\n * ## saw\n * this is a trigonometric function (like Math.sin, or Math.cos), it takes an\n * angle in radians and returns a value between -1 and 1, the \"shape\" of the\n * returned values follows a linear \"sawtooth\" pattern\n *\n * @export\n * @param {number} radians a value in radians (clamped between 0 and ππ)\n * @returns {number} a value between -1 and 1 for entry values between 0 and ππ\n */\nexport function saw(radians: number): number {\n  return (radians % ππ) / π - 1;\n}\n\n/**\n * ## tri\n * this is a trigonometric function (like Math.sin, or Math.cos), it takes an\n * angle in radians and returns a value between -1 and 1, the \"shape\" of the\n * returned values follows a linear \"triangle wave\" pattern\n *\n * @export\n * @param {number} radians a value in radians (clamped between 0 and ππ)\n * @returns {number} a value between -1 and 1 for entry values between 0 and ππ\n */\nexport function tri(radians: number): number {\n  return 1 - 2 * abs(saw(radians));\n}\n\n/**\n * ## toDegrees\n * takes an angle in radians and returns that angle in degrees\n *\n * @param {number} radians an angle, in radians\n * @return {number} that same angle, in degrees\n */\nexport function toDegrees(radians: number): number {\n  return (radians * 180) / π;\n}\n\n/**\n * ## toRadians\n * takes an angle in degrees and returns that angle in radians\n *\n * @param {number} degrees an angle, in degrees\n * @return {number} that same angle, in radians\n */\nexport function toRadians(degrees: number): number {\n  return (degrees * π) / 180;\n}\n","import type { Listener } from './types';\n\nexport const el = <T extends keyof HTMLElementTagNameMap>(\n  selector: T,\n): HTMLElementTagNameMap[T] =>\n  document.querySelector(selector) ?? document.createElement(selector);\n\nexport const on = <T extends EventTarget, U extends keyof DocumentEventMap>(\n  target: T,\n  forEvent: U,\n  listener: Listener<U>,\n  options: boolean | AddEventListenerOptions = false,\n): void => target.addEventListener(forEvent, listener, options);\n","import { π } from '../../../lib/core/math';\nimport type { AppState } from './types';\n\nconst hπ = π / 2;\n\nexport const topLeft = (\n  { ctx }: Pick<AppState, 'ctx'>,\n  x: number,\n  y: number,\n  r: number,\n): void => ctx.arc(x, y, r, π, π + hπ);\n\nexport const topRight = (\n  { ctx }: Pick<AppState, 'ctx'>,\n  x: number,\n  y: number,\n  r: number,\n): void => ctx.arc(x, y, r, π + hπ, 0);\n\nexport const bottomRight = (\n  { ctx }: Pick<AppState, 'ctx'>,\n  x: number,\n  y: number,\n  r: number,\n): void => ctx.arc(x, y, r, 0, hπ);\n\nexport const bottomLeft = (\n  { ctx }: Pick<AppState, 'ctx'>,\n  x: number,\n  y: number,\n  r: number,\n): void => ctx.arc(x, y, r, hπ, π);\n\n/**\n * apparently this is coming to canvas at some point\n * @see https://www.chromestatus.com/feature/5678204184428544\n * @see https://github.com/fserb/canvas2D/blob/master/spec/roundrect.md\n */\nexport const roundRect = (\n  { ctx }: Pick<AppState, 'ctx'>,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  r: number,\n): void => {\n  ctx.beginPath();\n\n  // top left\n  topLeft({ ctx }, x + r, y + r, r);\n  ctx.lineTo(x + w - r, y);\n\n  // top right\n  topRight({ ctx }, x + w - r, y + r, r);\n  ctx.lineTo(x + w, y + h - r);\n\n  // bottom right\n  bottomRight({ ctx }, x + w - r, y + h - r, r);\n  ctx.lineTo(x + w - r, y + h);\n\n  // bottom left\n  bottomLeft({ ctx }, x + r, y + h - r, r);\n  ctx.lineTo(x, y + r);\n};\n\nexport const gridRect = (\n  {\n    ctx,\n    canvasWidth,\n    canvasHeight,\n  }: Pick<AppState, 'ctx' | 'canvasWidth' | 'canvasHeight'>,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  s: number,\n): void => {\n  ctx.beginPath();\n\n  for (let i = 0; i <= w; i += s) {\n    ctx.moveTo(x + i, 0);\n    ctx.lineTo(x + i, canvasHeight);\n  }\n\n  for (let j = 0; j <= h; j += s) {\n    ctx.moveTo(0, y + j);\n    ctx.lineTo(canvasWidth, y + j);\n  }\n};\n","import { floor, random } from '../../../lib/core/math';\n\n/**\n * ```\n * ∙ ╭ ─ ─ ╮ ∙\n * ╭ ╯ ∙ ∙ ╰ ╮\n * │ ∙ ╭ ╮ ∙ │\n * │ ∙ ╰ ╯ ∙ │\n * ╰ ╮ ∙ ∙ ╭ ╯\n * ∙ ╰ ─ ─ ╯ ∙\n * ```\n */\nconst allowedNeighbors: {\n  [k: string]: {\n    up: string;\n    right: string;\n    down: string;\n    left: string;\n  };\n} = {\n  '╭': {\n    up: '∙─╯╰',\n    right: '─╮╯',\n    down: '│╯╰',\n    left: '∙│╯╮',\n  },\n  '╮': {\n    up: '∙─╯╰',\n    right: '∙│╭╰',\n    down: '│╯╰',\n    left: '╭╰─',\n  },\n  '╯': {\n    up: '│╮╭',\n    right: '∙│╭╰',\n    down: '∙─╮╭',\n    left: '╭╰─',\n  },\n  '╰': {\n    up: '│╮╭',\n    right: '─╮╯',\n    down: '∙─╮╭',\n    left: '∙│╯╮',\n  },\n  '│': {\n    up: '│╮╭',\n    right: '∙│╭╰',\n    down: '│╯╰',\n    left: '∙│╯╮',\n  },\n  '─': {\n    up: '∙─╯╰',\n    right: '─╮╯',\n    down: '∙─╮╭',\n    left: '╭╰─',\n  },\n  '∙': {\n    up: '∙─╯╰',\n    right: '∙│╭╰',\n    down: '∙─╮╭',\n    left: '∙│╯╮',\n  },\n};\n\nconst chance = (n: number) => random() < n;\n\nexport const generate = (cols: number, rows: number): string[][] => {\n  const cells: string[][] = [];\n\n  for (let i = 0; i < rows; ++i) {\n    cells[i] = [];\n    for (let j = 0; j < cols; ++j) {\n      cells[i][j] =\n        i === 0 || j === 0 || i === rows - 1 || j === cols - 1 ? '∙' : '';\n    }\n  }\n\n  for (let i = 1; i < rows - 1; ++i) {\n    for (let j = 1; j < cols - 1; ++j) {\n      const neighborUp = cells[i - 1]?.[j];\n      const neighborRight = cells[i][j + 1];\n      const neighborDown = cells[i + 1]?.[j];\n      const neighborLeft = cells[i][j - 1];\n\n      /**\n       * this might be kind of confusing to future me, but I'm using \"downward\n       * neighbor\" to get the \"upward constraint\" and so on, because this is\n       * working top to bottom and left to right it's mostly downward and right-\n       * ward constraints\n       */\n      const allowedUp = allowedNeighbors[neighborDown]?.up ?? '';\n      const allowedRight = allowedNeighbors[neighborLeft]?.right ?? '';\n      const allowedDown = allowedNeighbors[neighborUp]?.down ?? '';\n      const allowedLeft = allowedNeighbors[neighborRight]?.left ?? '';\n\n      const allowedCells = (\n        allowedUp +\n        allowedRight +\n        allowedDown +\n        allowedLeft\n      )\n        .split('')\n        .filter(\n          (c) =>\n            // only check for includes if the constraint is a non-empty string\n            (allowedUp !== '' ? allowedUp.includes(c) : true) &&\n            (allowedRight !== '' ? allowedRight.includes(c) : true) &&\n            (allowedDown !== '' ? allowedDown.includes(c) : true) &&\n            (allowedLeft !== '' ? allowedLeft.includes(c) : true),\n        )\n        .join('');\n\n      // prefer empty spaces as neighbors to straight lines\n      if (\n        (neighborRight === '│' ||\n          neighborLeft === '│' ||\n          neighborUp === '─' ||\n          neighborDown === '─') &&\n        allowedCells.includes('∙')\n      ) {\n        if (chance(7 / 10)) {\n          cells[i][j] = '∙';\n          continue;\n        }\n      }\n\n      // prefer empty spaces as neighbors to empty spaces\n      if (\n        (neighborRight === '∙' ||\n          neighborLeft === '∙' ||\n          neighborUp === '∙' ||\n          neighborDown === '∙') &&\n        allowedCells.includes('∙')\n      ) {\n        if (chance(7 / 10)) {\n          cells[i][j] = '∙';\n          continue;\n        }\n      }\n\n      // prefer continuing vertical lines\n      if (\n        (neighborUp === '│' || neighborDown === '│') &&\n        allowedCells.includes('│')\n      ) {\n        if (chance(5 / 10)) {\n          cells[i][j] = '│';\n          continue;\n        }\n      }\n\n      // prefer continuing horizontal lines\n      if (\n        (neighborRight === '─' || neighborLeft === '─') &&\n        allowedCells.includes('─')\n      ) {\n        if (chance(5 / 10)) {\n          cells[i][j] = '─';\n          continue;\n        }\n      }\n\n      cells[i][j] = allowedCells.charAt(floor(random() * allowedCells.length));\n    }\n  }\n\n  return cells;\n};\n","import { ceil, floor, min, ππ } from '../../../lib/core/math';\nimport { el, on } from './dom-utils';\nimport {\n  bottomLeft,\n  bottomRight,\n  gridRect,\n  roundRect,\n  topLeft,\n  topRight,\n} from './drawing-utils';\nimport { generate } from './map';\nimport './style.css';\nimport type { AppState } from './types';\n\nconst canvas = el('canvas');\nconst ctx = canvas.getContext('2d');\n\nif (!ctx) {\n  throw new Error(`Expected \\`CanvasRenderingContext2D\\` but got ${ctx}`);\n}\n\nconst resize = () => {\n  const { innerWidth, innerHeight } = window;\n  const doubleWidth = ceil(innerWidth * 2);\n  const doubleHeight = ceil(innerHeight * 2);\n\n  canvas.width = doubleWidth;\n  canvas.height = doubleHeight;\n  canvas.style.width = `${doubleWidth}px`;\n  canvas.style.height = `${doubleHeight}px`;\n  canvas.style.transform = 'scale(0.5)';\n\n  draw();\n};\n\nconst getState = (): AppState => {\n  const { width: canvasWidth, height: canvasHeight } = canvas;\n\n  const safeWidth = canvasWidth * 0.9;\n  const safeHeight = canvasHeight * 0.9;\n\n  const halfWidth = canvasWidth / 2;\n  const halfHeight = canvasHeight / 2;\n\n  const r = min(halfWidth, halfHeight) * 0.05;\n  const lineWidth = r / 2;\n\n  const step = r * 2;\n  const cols = floor(safeWidth / step);\n  const rows = floor(safeHeight / step);\n  const rectWidth = cols * step;\n  const rectHeight = rows * step;\n\n  return {\n    ctx,\n    canvasWidth,\n    canvasHeight,\n    safeWidth,\n    safeHeight,\n    halfWidth,\n    halfHeight,\n    r,\n    step,\n    rectWidth,\n    rectHeight,\n    lineWidth,\n    map: generate(cols + 2, rows + 2),\n  };\n};\n\nconst bkgd = ({ ctx, canvasWidth, canvasHeight }: AppState) => {\n  ctx.fillStyle = 'hsl(100, 40%, 60%)';\n  ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n};\n\nconst pond = ({\n  ctx,\n  halfWidth,\n  halfHeight,\n  rectWidth,\n  rectHeight,\n  lineWidth,\n  step,\n  r,\n  map,\n}: AppState) => {\n  ctx.strokeStyle = 'hsl(50, 10%, 90%)';\n  ctx.lineWidth = lineWidth;\n\n  ctx.save();\n  ctx.translate(\n    halfWidth - rectWidth / 2 - step,\n    halfHeight - rectHeight / 2 - step,\n  );\n\n  map.forEach((row, i) =>\n    row.forEach((cell, j) => {\n      ctx.beginPath();\n\n      switch (cell) {\n        case '╭':\n          topLeft({ ctx }, j * step + step, i * step + step, r);\n          break;\n        case '╮':\n          topRight({ ctx }, j * step, i * step + step, r);\n          break;\n        case '╯':\n          bottomRight({ ctx }, j * step, i * step, r);\n          break;\n        case '╰':\n          bottomLeft({ ctx }, j * step + step, i * step, r);\n          break;\n        case '│':\n          ctx.moveTo(j * step + step / 2, i * step);\n          ctx.lineTo(j * step + step / 2, i * step + step);\n          break;\n        case '─':\n          ctx.moveTo(j * step, i * step + step / 2);\n          ctx.lineTo(j * step + step, i * step + step / 2);\n          break;\n        case '∙':\n          break;\n      }\n\n      ctx.stroke();\n    }),\n  );\n\n  ctx.restore();\n};\n\nconst grid = ({\n  ctx,\n  canvasWidth,\n  canvasHeight,\n  halfWidth,\n  halfHeight,\n  rectWidth,\n  rectHeight,\n  step,\n}: AppState) => {\n  ctx.strokeStyle = 'hsla(0, 0%, 20%, 20%)';\n  ctx.lineWidth = 1;\n\n  ctx.setLineDash([]);\n  gridRect(\n    { ctx, canvasWidth, canvasHeight },\n    halfWidth - rectWidth / 2,\n    halfHeight - rectHeight / 2,\n    rectWidth,\n    rectHeight,\n    step,\n  );\n  ctx.stroke();\n};\n\nconst draw = () => {\n  const state = getState();\n  bkgd(state);\n\n  if (process.env.NODE_ENV === 'development') {\n    grid(state);\n  }\n\n  pond(state);\n};\n\non(window, 'resize', resize);\nresize();\n"]}