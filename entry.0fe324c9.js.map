{"version":3,"sources":["../lib/core/dom.ts","../lib/core/math.ts","09-bezier/src/resize.ts","09-bezier/src/entry.ts"],"names":[],"mappings":"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","file":"entry.0fe324c9.js","sourceRoot":"../src/lab","sourcesContent":["export const {\n  requestAnimationFrame: rAF,\n  cancelAnimationFrame: cAF,\n  devicePixelRatio: dpr,\n} = window;\n\nexport function el(selectors: string): Element | null {\n  return document.querySelector(selectors);\n}\n\ntype Listener<T extends Event> = (event: T) => void;\n\nexport function on<T extends Event>(type: string, listener: Listener<T>): void {\n  return window.addEventListener(type, listener as EventListener);\n}\n\nexport function off<T extends Event>(\n  type: string,\n  listener: Listener<T>,\n): void {\n  return window.removeEventListener(type, listener as EventListener);\n}\n","export const {\n  abs,\n  acos,\n  atan2,\n  ceil,\n  cos,\n  floor,\n  hypot,\n  max,\n  min,\n  PI: π,\n  pow,\n  round,\n  sin,\n  sqrt,\n} = Math;\nexport const ππ = π * 2;\nexport const { isFinite } = Number;\n\n/**\n * ## lerp\n * short for \"linear interpolate\" this function returns a number that is\n * interpolated between `a` and `b` by the ratio provided in `i` (e.g. if `i` is\n * 0 `a` is returned, if `i` is 1 `b` is returned)\n *\n * @export\n * @param {number} v0 the lower bound of the interpolation\n * @param {number} v1 the upper bound of the interpolation\n * @param {number} t the ratio by which to interpolate between `a` and `b`\n * @returns {number} a number that is interpolated between `a` and `b` by the\n * ratio provided in `i`\n */\nexport function lerp(v0: number, v1: number, t: number): number {\n  /**\n   * prefer precise method\n   * @see: https://github.com/mattdesl/lerp/blob/master/index.js\n   * @see: https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\n   */\n  return (1 - t) * v0 + t * v1;\n}\n\n/**\n * ## saw\n * this is a trigonometric function (like Math.sin, or Math.cos), it takes an\n * angle in radians and returns a value between -1 and 1, the \"shape\" of the\n * returned values follows a linear \"sawtooth\" pattern\n *\n * @export\n * @param {number} radians a value in radians (clamped between 0 and ππ)\n * @returns {number} a value between -1 and 1 for entry values between 0 and ππ\n */\nexport function saw(radians: number): number {\n  return (radians % ππ) / π - 1;\n}\n\n/**\n * ## tri\n * this is a trigonometric function (like Math.sin, or Math.cos), it takes an\n * angle in radians and returns a value between -1 and 1, the \"shape\" of the\n * returned values follows a linear \"triangle wave\" pattern\n *\n * @export\n * @param {number} radians a value in radians (clamped between 0 and ππ)\n * @returns {number} a value between -1 and 1 for entry values between 0 and ππ\n */\nexport function tri(radians: number): number {\n  return 1 - 2 * abs(saw(radians));\n}\n\n/**\n * ## toDegrees\n * takes an angle in radians and returns that angle in degrees\n *\n * @param {number} radians an angle, in radians\n * @return {number} that same angle, in degrees\n */\nexport function toDegrees(radians: number): number {\n  return (radians * 180) / π;\n}\n\n/**\n * ## toRadians\n * takes an angle in degrees and returns that angle in radians\n *\n * @param {number} degrees an angle, in degrees\n * @return {number} that same angle, in radians\n */\nexport function toRadians(degrees: number): number {\n  return (degrees * π) / 180;\n}\n","import { on } from '../../../lib/core/dom';\nimport { max } from '../../../lib/core/math';\n\nfunction nextMultiple(multipleOf = 1, startingFrom = 0) {\n  return startingFrom % multipleOf !== 0\n    ? startingFrom + (multipleOf - (startingFrom % multipleOf))\n    : startingFrom;\n}\n\nlet didResizeWindow = true;\non('resize', () => {\n  didResizeWindow = true;\n});\n\nexport function shouldResize() {\n  return didResizeWindow;\n}\n\nexport function resize(\n  canvas: HTMLCanvasElement,\n  container: HTMLElement,\n  scale = 1,\n): void {\n  if (!didResizeWindow) {\n    return;\n  }\n\n  didResizeWindow = false;\n\n  const { devicePixelRatio: dpr } = window;\n  const { clientHeight: h, clientWidth: w } = container;\n\n  const width = nextMultiple(scale, w);\n  const height = nextMultiple(scale, h);\n\n  canvas.width = (width * dpr) / scale;\n  canvas.height = (height * dpr) / scale;\n\n  canvas.style.transform = `scale(${max(w / canvas.width, h / canvas.height)})`;\n}\n","import { el, rAF, on } from '../../../lib/core/dom';\nimport { min, ππ, hypot, lerp, max, abs } from '../../../lib/core/math';\n\nimport { resize, shouldResize } from './resize';\n\nimport './style.css';\n\nconst { devicePixelRatio: dpr } = window;\n\nconst m = el('main') as HTMLMainElement;\nconst c = el('canvas') as HTMLCanvasElement;\nconst ctx = c.getContext('2d') as CanvasRenderingContext2D;\n\nlet graphSize = 0;\nlet hs = 0;\n\nlet w = 0;\nlet h = 0;\nlet hw = 0;\nlet hh = 0;\n\nlet pointerX = 0;\nlet pointerY = 0;\n\ninterface Handle {\n  ox: number;\n  oy: number;\n  x: number;\n  y: number;\n  sx: number;\n  sy: number;\n  isDragging: boolean;\n}\n\nconst handles: Handle[] = [\n  {\n    ox: 0,\n    oy: 0,\n    x: 0,\n    y: 0,\n    sx: 0,\n    sy: 0,\n    isDragging: false,\n  },\n  {\n    ox: 0,\n    oy: 0,\n    x: 0,\n    y: 0,\n    sx: 0,\n    sy: 0,\n    isDragging: false,\n  },\n];\n\nconst handleRadius = 30;\n\nfunction onMouseDown(event: MouseEvent) {\n  pointerX = event.clientX * dpr;\n  pointerY = event.clientY * dpr;\n\n  handles.forEach(handle => {\n    handle.isDragging =\n      hypot(pointerX - handle.x, pointerY - handle.y) < handleRadius;\n  });\n}\n\nfunction onMouseUp() {\n  handles.forEach(handle => {\n    handle.isDragging = false;\n  });\n}\n\nfunction onMouseMove(event: MouseEvent) {\n  pointerX = event.clientX * dpr;\n  pointerY = event.clientY * dpr;\n\n  m.style.cursor = handles.some(\n    handle => hypot(pointerX - handle.x, pointerY - handle.y) < handleRadius,\n  )\n    ? 'pointer'\n    : 'default';\n}\n\nfunction onTouchStart(event: TouchEvent) {\n  pointerX = event.touches[0].clientX * dpr;\n  pointerY = event.touches[0].clientY * dpr;\n\n  handles.forEach(handle => {\n    handle.isDragging =\n      hypot(pointerX - handle.x, pointerY - handle.y) < handleRadius;\n  });\n}\n\nfunction onTouchEnd() {\n  handles.forEach(handle => {\n    handle.isDragging = false;\n  });\n}\n\nfunction onTouchMove(event: TouchEvent) {\n  pointerX = event.touches[0].clientX * dpr;\n  pointerY = event.touches[0].clientY * dpr;\n}\n\non<MouseEvent>('mousedown', onMouseDown);\non<MouseEvent>('mouseup', onMouseUp);\non<MouseEvent>('mousemove', onMouseMove);\n\non<TouchEvent>('touchstart', onTouchStart);\non<TouchEvent>('touchend', onTouchEnd);\non<TouchEvent>('touchmove', onTouchMove);\n\nfunction drawShadow() {\n  ctx.strokeStyle = 'hsl(0,0%,40%)';\n  ctx.strokeRect(hw, hh - hs, graphSize, graphSize);\n\n  handles.forEach(handle => {\n    ctx.beginPath();\n    ctx.arc(handle.sx, handle.sy, handleRadius, 0, ππ);\n    ctx.moveTo(hw + abs(hw - handle.ox), handle.oy);\n    ctx.lineTo(handle.sx, handle.sy);\n    ctx.stroke();\n  });\n\n  ctx.beginPath();\n  ctx.moveTo(hw + abs(hw - handles[0].ox), handles[0].oy);\n  ctx.bezierCurveTo(\n    handles[0].sx,\n    handles[0].sy,\n    handles[1].sx,\n    handles[1].sy,\n    handles[1].ox,\n    handles[1].oy,\n  );\n  ctx.stroke();\n}\n\nfunction drawGraph() {\n  ctx.strokeStyle = 'hsl(0,0%,90%)';\n  ctx.strokeRect(hw - graphSize, hh - hs, graphSize, graphSize);\n\n  handles.forEach(handle => {\n    if (handle.isDragging) {\n      handle.x = min(max(hw - graphSize, lerp(handle.x, pointerX, 0.5)), hw);\n      handle.y = lerp(handle.y, pointerY, 0.5);\n\n      handle.sx = hw + abs(hw - handle.x);\n      handle.sy = handle.oy + handle.oy - handle.y;\n    }\n\n    ctx.beginPath();\n    ctx.arc(handle.x, handle.y, handleRadius, 0, ππ);\n    ctx.moveTo(handle.ox, handle.oy);\n    ctx.lineTo(handle.x, handle.y);\n    ctx.stroke();\n  });\n\n  ctx.beginPath();\n  ctx.moveTo(handles[0].ox, handles[0].oy);\n  ctx.bezierCurveTo(\n    handles[0].x,\n    handles[0].y,\n    handles[1].x,\n    handles[1].y,\n    handles[1].ox,\n    handles[1].oy,\n  );\n  ctx.stroke();\n}\n\nfunction draw(/* ts: number */) {\n  rAF(draw);\n\n  if (shouldResize()) {\n    resize(c, m);\n    const { width, height } = c;\n\n    w = width;\n    h = height;\n    hw = w / 2;\n    hh = h / 2;\n\n    graphSize = min(c.width, c.height) * 0.4;\n    hs = graphSize / 2;\n\n    handles.forEach((handle, i) => {\n      handle.x = hw - hs;\n      handle.y = hh + hs - graphSize * i;\n    });\n\n    handles[0].ox = hw - graphSize;\n    handles[0].oy = hh + hs;\n\n    handles[1].ox = hw;\n    handles[1].oy = hh - hs;\n\n    handles.forEach(handle => {\n      handle.sx = hw + abs(hw - handle.x);\n      handle.sy = handle.oy + handle.oy - handle.y;\n    });\n  }\n\n  ctx.clearRect(0, 0, c.width, c.height);\n\n  ctx.lineWidth = 3;\n  drawShadow();\n  drawGraph();\n}\n\nrAF(draw);\n"]}