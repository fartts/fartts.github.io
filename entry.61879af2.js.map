{"version":3,"sources":["../lib/core/math.ts","../lib/core/wave.ts","17-gradient-texture/src/lib/browser-utils.ts","17-gradient-texture/src/lib/resize.ts","17-gradient-texture/src/entry.ts"],"names":[],"mappings":";AA0FC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,KAAA,EAAA,QAAA,IAAA,EAAA,QAAA,IAAA,EAAA,QAAA,UAAA,EAAA,QAAA,UAAA,EAAA,QAAA,SAAA,QAAA,GAAA,QAAA,KAAA,QAAA,IAAA,QAAA,MAAA,QAAA,OAAA,QAAA,IAAA,QAAA,EAAA,QAAA,IAAA,QAAA,IAAA,QAAA,MAAA,QAAA,MAAA,QAAA,IAAA,QAAA,KAAA,QAAA,MAAA,QAAA,KAAA,QAAA,SAAA,EA1FM,MAAM,IACX,EADW,KAEX,EAFW,MAGX,EAHW,KAIX,EAJW,IAKX,EALW,MAMX,EANW,MAOX,EAPW,IAQX,EARW,IASX,EACA,GAAI,EAVO,IAWX,EAXW,OAYX,EAZW,MAaX,EAbW,IAcX,EAdW,KAeX,GACE,KA0EH,QAAA,KAAA,EAAA,QAAA,IAAA,EAAA,QAAA,MAAA,EAAA,QAAA,OAAA,EAAA,QAAA,IAAA,EAAA,QAAA,EAAA,EAAA,QAAA,IAAA,EAAA,QAAA,IAAA,EAAA,QAAA,MAAA,EAAA,QAAA,MAAA,EAAA,QAAA,IAAA,EAAA,QAAA,KAAA,EAAA,QAAA,MAAA,EAAA,QAAA,KAAA,EAAA,QAAA,IAAA,EAzEM,MAAM,EAAS,EAAJ,EAyEjB,QAAA,GAAA,EAxEM,MAAM,SAAE,GAAa,OAetB,SAAU,EAAK,EAAY,EAAY,GAMpC,OAAC,EAAI,GAAK,EAAK,EAAI,EAatB,SAAU,EAAI,GACV,OAAA,EAAU,EAAM,EAAI,EAaxB,SAAU,EAAI,GACX,OAAA,EAAI,EAAI,EAAI,EAAI,IAUnB,SAAU,EAAU,GAChB,OAAU,IAAV,EAAiB,EAUrB,SAAU,EAAU,GAChB,OAAA,EAAU,EAAK,IACxB,QAAA,SAAA;;ACnCM,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,KAAA,EAAA,QAAA,QAAA,QAAA,QAAA,QAAA,QAAA,QAAA,aAAA,EAvDP,IAAA,EAAA,QAAA,UAuBM,SAAU,EACd,EACA,EAAI,IACJ,GAAM,EACN,EAAM,EACN,EAAI,GAME,MAAA,GAAO,EAAM,GAAO,EAMpB,EAAM,EAAK,GAAA,EAET,OAAA,IAEC,OAAA,GAAO,EAAI,GADN,EAAI,GACW,IAAQ,GAWhC,MAAO,EAAS,EAAS,EAAS,GAAkC,CACzE,CAAC,EAAI,IAAM,GAAM,EAAI,EAAM,EAAG,EAAI,IAAM,EAAK,EAAD,IAAM,EAAG,EAAK,EAAK,GAC/D,CAAC,EAAI,IAAM,GAAM,EAAI,EAAM,EAAG,EAAI,IAAM,EAAK,EAAD,IAAM,EAAG,EAAK,EAAK,GAC/D,CAAC,EAAI,IAAM,GAAM,EAAI,EAAM,EAAG,EAAI,IAAM,EAAK,EAAD,IAAM,EAAG,EAAK,EAAK,GAC/D,CAAC,EAAI,IAAM,GAAM,EAAI,EAAM,EAAG,EAAI,IAAM,EAAK,EAAD,IAAM,EAAG,EAAK,EAAK,IAJ1D,QAAA,QAAA,EAAA,QAAA,QAAA,EAAA,QAAA,QAAA,EAAA,QAAA,QAAA;;ACxBA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,IAAA,QAAA,GAAA,QAAA,GAAA,QAAA,IAAA,QAAA,IAAA,QAAA,SAAA,EA/BA,MACL,sBAAuB,EACvB,qBAAsB,EACtB,iBAAkB,GAChB,OA2BG,QAAA,IAAA,EAAA,QAAA,IAAA,EAAA,QAAA,IAAA,EAzBA,MAAM,EAAyB,IAC9B,MAAA,EAAU,SAAS,cAAiB,GACtC,GAAY,OAAZ,EAAkB,OAAO,EAEvB,MAAA,IAAI,uBAAuB,eAqB5B,QAAA,GAAA,EAHA,MAAM,EAAc,CAAC,EAAQ,EAAU,EAAU,GAAU,IAChE,EAAO,iBAAiB,EAAU,EAAU,GAEvC,QAAA,GAAA,EAAA,MAAM,EAAe,CAAC,EAAQ,EAAU,EAAU,GAAU,IACjE,EAAO,oBAAoB,EAAU,EAAU,GAD1C,QAAA,IAAA;;ACHN,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,OAAA,EA5BD,IAAA,EAAA,QAAA,6BAEA,EAAA,QAAA,mBAOA,MAAM,EAAU,CAAC,EAAa,EAAG,EAAa,IAC5C,EAAa,GAAe,EACxB,GAAc,EAAc,EAAa,GACzC,EAEA,SAAU,EACd,EACA,EACA,EAAQ,GAEF,MAAE,aAAc,EAAG,YAAa,GAAM,EAEtC,EAAQ,EAAQ,EAAO,GACvB,EAAS,EAAQ,EAAO,GAE9B,EAAO,MAAS,EAAQ,EAAT,IAAgB,EAC/B,EAAO,OAAU,EAAS,EAAV,IAAiB,EAEjC,EAAO,MAAM,oBAAqB,EAAI,EAAA,KAAA,EAAI,EAAO,MAAO,EAAI,EAAO;;;;;;ACgIpE,aA3JD,IAAA,EAAA,QAAA,0BACA,EAAA,QAAA,0BAEA,EAAA,QAAA,uBACA,EAAA,QAAA,gBAEA,QAAA,eAEA,MAAM,GAAO,EAAgB,EAAA,IAAA,QACvB,GAAS,EAAsB,EAAA,IAAA,UAC/B,EAAU,EAAO,WAAW,KAAM,CACtC,OAAO,IAIT,IAAK,EACG,MAAA,IAAI,MAAM,6CAGlB,IAAI,GAAe,GACnB,EAAG,EAAA,IAAA,OAAQ,SAAU,KACnB,GAAe,IAGjB,MAAM,EAAY,IAAQ,GAC1B,IAAI,EAAU,EAEV,EAAY,EACZ,EAAO,EACP,EAAW,EACX,EAAY,EACZ,EAAW,EAEf,MAAM,EAAI,KACJ,GAAQ,EAAQ,EAAA,SAAA,GAAI,EAAG,GACvB,GAAQ,EAAQ,EAAA,SAAA,GAAI,EAAG,GAE7B,IAAI,EAAK,EAAM,GACX,EAAK,EAAM,GAEf,MAAM,EAAS,CAAC,EAAW,KACzB,EAAK,EAAM,GACX,EAAK,EAAM,IAGP,EAAO,CAAC,EAAW,EAAW,KAClC,EAAQ,YACR,EAAQ,OAAO,EAAI,EAAG,GACtB,EAAQ,OAAO,EAAI,EAAG,GACtB,EAAQ,OAAO,EAAG,EAAI,GACtB,EAAQ,OAAO,EAAG,EAAI,GACtB,EAAQ,UAGJ,EAAU,IACR,MAAE,MAAO,EAAG,OAAQ,GAAM,EAE1B,EAAK,EAAI,EACT,EAAK,EAAI,EACT,GAAI,EAAI,EAAA,KAAA,EAAG,GAAK,EAEhB,GAAI,EAAM,EAAA,OAAA,EAAI,GACd,EAAK,GAAK,EAAI,EAAA,KAAA,GAAK,EAAI,EACvB,EAAK,GAAK,EAAI,EAAA,KAAA,GAAK,EAAI,EACvB,EAAK,GAAK,EAAI,EAAA,KAAA,GAAK,EAAI,EACvB,EAAK,GAAK,EAAI,EAAA,KAAA,GAAK,EAAI,EAEvB,EAAW,EAAQ,qBAAqB,EAAI,EAAI,EAAI,GACpD,GAAM,EAAU,EAAA,WAAA,GAGjB,IAAA,IAAI,EAAI,EAAG,EADN,GACa,GAAK,EAC1B,EAAS,aACP,EAAK,YACI,EAAQ,IAJX,GAIsB,EAAK,IAAM,wBAEzC,EAAS,cAAc,EAAI,GANnB,GAM2B,eAGrC,EAAQ,UAAY,QACpB,EAAQ,SAAS,EAAG,EAAG,EAAG,GAE1B,EAAQ,UAAY,EACpB,EAAQ,QAAQ,EAAK,EAAI,EAAK,EAAI,EAAG,EAAG,EAAG,EAAG,EAA9C,IACA,EAAQ,OAER,EAAQ,YAAc,cACtB,EAAK,EAAI,EAAI,KACb,EAAK,EAAI,EAAI,MAGT,EAAQ,IAYL,IAXP,GAAU,EAAI,EAAA,KAAA,GAEd,IAAc,EAAY,GAG1B,GADA,GADA,EAAO,EAAW,GACC,EAGf,IACK,EAAA,EAAA,QAAA,EAAM,EAAQ,IAGhB,GA/ES,IAAQ,IAgFtB,EAAO,GACP,GAjFc,IAAQ,GAoFxB,IAEA,EAAW,GAKb,GAFA,GAAU,EAAI,EAAA,KAAA,GAEV,kBAAmB,QAAU,cAAc,gBAAgB,cAAe,CACtE,MAAA,EAAS,SAAS,cAAc,UACtC,EAAO,UAAY,OAEnB,EAAO,iBAAiB,QAAS,KAEzB,MAAA,EAAS,EAAO,cAAc,IAC9B,EAAW,IAAI,cAAc,EAAQ,CACzC,SAAU,aACV,mBAAoB,MAEhB,EAAqB,GAE3B,EAAS,gBAAmB,CAAA,GAAU,EAAO,KAAK,EAAM,OACxD,EAAS,OAAS,MACV,MAAA,EAAO,IAAI,KAAK,EAAQ,CAC5B,KAAM,eAEF,EAAM,IAAI,gBAAgB,GAC1B,EAAI,SAAS,cAAc,KAEjC,EAAE,aAAa,OAAQ,GACvB,EAAE,aAAa,WAAY,yBAC3B,EAAE,aAAa,SAAU,UACzB,EAAE,MAAM,QAAU,OAElB,SAAS,KAAK,YAAY,GAE1B,EAAE,QACF,SAAS,KAAK,YAAY,GAC1B,IAAI,gBAAgB,KAIpB,EAAS,QACT,WAAW,IAAM,EAAS,OAAQ,KAItC,EAAK,YAAY","file":"entry.61879af2.js","sourceRoot":"../src/lab","sourcesContent":["export const {\n  abs,\n  acos,\n  atan2,\n  ceil,\n  cos,\n  floor,\n  hypot,\n  max,\n  min,\n  PI: π,\n  pow,\n  random,\n  round,\n  sin,\n  sqrt,\n} = Math;\nexport const ππ = π * 2;\nexport const { isFinite } = Number;\n\n/**\n * ## lerp\n * short for \"linear interpolate\" this function returns a number that is\n * interpolated between `a` and `b` by the ratio provided in `i` (e.g. if `i` is\n * 0 `a` is returned, if `i` is 1 `b` is returned)\n *\n * @export\n * @param {number} v0 the lower bound of the interpolation\n * @param {number} v1 the upper bound of the interpolation\n * @param {number} t the ratio by which to interpolate between `a` and `b`\n * @returns {number} a number that is interpolated between `a` and `b` by the\n * ratio provided in `i`\n */\nexport function lerp(v0: number, v1: number, t: number): number {\n  /**\n   * prefer precise method\n   * @see: https://github.com/mattdesl/lerp/blob/master/index.js\n   * @see: https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\n   */\n  return (1 - t) * v0 + t * v1;\n}\n\n/**\n * ## saw\n * this is a trigonometric function (like Math.sin, or Math.cos), it takes an\n * angle in radians and returns a value between -1 and 1, the \"shape\" of the\n * returned values follows a linear \"sawtooth\" pattern\n *\n * @export\n * @param {number} radians a value in radians (clamped between 0 and ππ)\n * @returns {number} a value between -1 and 1 for entry values between 0 and ππ\n */\nexport function saw(radians: number): number {\n  return (radians % ππ) / π - 1;\n}\n\n/**\n * ## tri\n * this is a trigonometric function (like Math.sin, or Math.cos), it takes an\n * angle in radians and returns a value between -1 and 1, the \"shape\" of the\n * returned values follows a linear \"triangle wave\" pattern\n *\n * @export\n * @param {number} radians a value in radians (clamped between 0 and ππ)\n * @returns {number} a value between -1 and 1 for entry values between 0 and ππ\n */\nexport function tri(radians: number): number {\n  return 1 - 2 * abs(saw(radians));\n}\n\n/**\n * ## toDegrees\n * takes an angle in radians and returns that angle in degrees\n *\n * @param {number} radians an angle, in radians\n * @return {number} that same angle, in degrees\n */\nexport function toDegrees(radians: number): number {\n  return (radians * 180) / π;\n}\n\n/**\n * ## toRadians\n * takes an angle in degrees and returns that angle in radians\n *\n * @param {number} degrees an angle, in degrees\n * @return {number} that same angle, in radians\n */\nexport function toRadians(degrees: number): number {\n  return (degrees * π) / 180;\n}\n","import { cos, saw, sin, tri, ππ } from './math';\n\nexport type TrigFunction = (radians: number) => number;\nexport type WaveFunction = (timestamp: number) => number;\n\n/**\n * ## wave\n * this utility function uses the provided trigonometric function to create a\n * wave function that takes a timestamp in milliseconds (optionally offset by\n * `o`) and that returns a value between `min` and `max` for the period `p`\n *\n * @export\n * @param {TrigFunction} fn the function to generate the wave (takes a value in\n * radians and returns a value between -1 and 1 at some interval)\n * @param {number} [p=1000] the period for this wave (in milliseconds)\n * @param {*} [min=-1] the minimum value for the generated wave\n * @param {number} [max=1] the maximum value for the generated wave\n * @param {number} [o=0] an optional offset (in milliseconds) at which to start\n * the wave\n * @returns {WaveFunction} a wave function that takes a timestamp in\n * milliseconds (optionally offset by `o`) and returns a value between `min` and\n * `max` for the period `p`\n */\nexport function wave(\n  fn: TrigFunction,\n  p = 1000,\n  min = -1,\n  max = 1,\n  o = 0,\n): WaveFunction {\n  /**\n   * peak amplitude (not peak-to-peak amplitude)\n   * @see https://en.wikipedia.org/wiki/Amplitude\n   */\n  const amp = (max - min) / 2;\n\n  /**\n   * radians per period (angular frequency)\n   * @see https://en.wikipedia.org/wiki/Angular_frequency\n   */\n  const rpp = ππ / p;\n\n  return (t: number) => {\n    const ots = o + t; // offset timestamp\n    return amp * (1 + fn(ots * rpp)) + min;\n  };\n}\n\ntype CurriedWaveFunction = (\n  p?: number,\n  min?: number,\n  max?: number,\n  o?: number,\n) => WaveFunction;\n\nexport const [cosWave, sawWave, sinWave, triWave]: CurriedWaveFunction[] = [\n  (p = 1000, min = -1, max = 1, o = 0) => wave(cos, p, min, max, o),\n  (p = 1000, min = -1, max = 1, o = 0) => wave(saw, p, min, max, o),\n  (p = 1000, min = -1, max = 1, o = 0) => wave(sin, p, min, max, o),\n  (p = 1000, min = -1, max = 1, o = 0) => wave(tri, p, min, max, o),\n];\n","export const {\n  requestAnimationFrame: raf,\n  cancelAnimationFrame: caf,\n  devicePixelRatio: dpr,\n} = window;\n\nexport const el = <T extends Element>(selectors: string): T => {\n  const element = document.querySelector<T>(selectors);\n  if (element !== null) return element;\n\n  throw new Error(`Couldn't get \"${selectors}\" element`);\n};\n\ninterface Listener<K extends keyof HTMLElementEventMap> extends EventListener {\n  (event: HTMLElementEventMap[K]): void;\n}\n\ntype Toggler = <\n  T extends EventTarget,\n  U extends keyof HTMLElementEventMap,\n  V extends EventListenerOptions\n>(\n  target: T,\n  forEvent: U,\n  listener: Listener<U>,\n  options?: boolean | V,\n) => void;\n\nexport const on: Toggler = (target, forEvent, listener, options = false) =>\n  target.addEventListener(forEvent, listener, options);\n\nexport const off: Toggler = (target, forEvent, listener, options = false) =>\n  target.removeEventListener(forEvent, listener, options);\n","import { max } from '../../../../lib/core/math';\n\nimport { dpr } from './browser-utils';\n\ninterface ResizeableElement extends HTMLElement {\n  width: number;\n  height: number;\n}\n\nconst nearest = (multipleOf = 1, startingAt = 0) =>\n  startingAt % multipleOf !== 0\n    ? startingAt + (multipleOf - (startingAt % multipleOf))\n    : startingAt;\n\nexport function resize(\n  container: HTMLElement,\n  target: ResizeableElement,\n  scale = 1,\n) {\n  const { clientHeight: h, clientWidth: w } = container;\n\n  const width = nearest(scale, w);\n  const height = nearest(scale, h);\n\n  target.width = (width * dpr) / scale;\n  target.height = (height * dpr) / scale;\n\n  target.style.transform = `scale(${max(w / target.width, h / target.height)})`;\n}\n","import { atan2, min, toDegrees, ππ, cos, sin } from '../../../lib/core/math';\nimport { cosWave, sinWave } from '../../../lib/core/wave';\n\nimport { el, on, raf } from './lib/browser-utils';\nimport { resize } from './lib/resize';\n\nimport './style.css';\n\nconst main = el<HTMLElement>('main');\nconst canvas = el<HTMLCanvasElement>('canvas');\nconst context = canvas.getContext('2d', {\n  alpha: false,\n  // desynchronized: true,\n});\n\nif (!context) {\n  throw new Error(\"Couldn't get a `CanvasRenderingContext2D`\");\n}\n\nlet shouldResize = true;\non(window, 'resize', () => {\n  shouldResize = true;\n});\n\nconst frameTime = 1_000 / 60;\nlet frameId = 0;\n\nlet startTime = 0;\nlet time = 0;\nlet prevTime = 0;\nlet deltaTime = 0;\nlet overTime = 0;\n\nconst p = 15_000;\nconst xWave = cosWave(p, -3, 3);\nconst yWave = sinWave(p, -3, 3);\n\nlet px = xWave(0);\nlet py = yWave(0);\n\nconst update = (t: number, _dt: number) => {\n  px = xWave(t);\n  py = yWave(t);\n};\n\nconst plus = (x: number, y: number, r: number) => {\n  context.beginPath();\n  context.moveTo(x - r, y);\n  context.lineTo(x + r, y);\n  context.moveTo(x, y - r);\n  context.lineTo(x, y + r);\n  context.stroke();\n};\n\nconst render = (_lag: number) => {\n  const { width: w, height: h } = canvas;\n\n  const hw = w / 2;\n  const hh = h / 2;\n  const r = min(w, h) / 4;\n\n  const a = atan2(py, px);\n  const x0 = hw - cos(a) * r + px;\n  const y0 = hh - sin(a) * r + py;\n  const x1 = hw + cos(a) * r + px;\n  const y1 = hh + sin(a) * r + py;\n\n  const gradient = context.createLinearGradient(x0, y0, x1, y1);\n  const hue = toDegrees(a);\n\n  const j = 42;\n  for (let i = 0; i < j; i += 2) {\n    gradient.addColorStop(\n      i / (j - 1),\n      `hsla(${(hue + ((360 / j) * i) / 14) % 360}, 80%, 50%, 0.85)`,\n    );\n    gradient.addColorStop((i + 1) / j, 'transparent');\n  }\n\n  context.fillStyle = 'black';\n  context.fillRect(0, 0, w, h);\n\n  context.fillStyle = gradient;\n  context.ellipse(hw + px, hh + py, r, r, 0, 0, ππ);\n  context.fill();\n\n  context.strokeStyle = 'transparent';\n  plus(x0, y0, 1.5);\n  plus(x1, y1, 1.5);\n};\n\nconst tick = (realTime: DOMHighResTimeStamp) => {\n  frameId = raf(tick);\n\n  startTime || (startTime = realTime); // tslint:disable-line:no-unused-expression\n  time = realTime - startTime;\n  deltaTime = time - prevTime;\n  overTime += deltaTime;\n\n  if (shouldResize) {\n    resize(main, canvas, 30);\n  }\n\n  while (overTime >= frameTime) {\n    update(time, frameTime);\n    overTime -= frameTime;\n  }\n\n  render(overTime / frameTime);\n\n  prevTime = time;\n};\n\nframeId = raf(tick);\n\nif ('MediaRecorder' in window && MediaRecorder.isTypeSupported('video/webm')) {\n  const button = document.createElement('button');\n  button.innerText = 'WEBM';\n\n  button.addEventListener('click', () => {\n    // @ts-ignore\n    const stream = canvas.captureStream(30);\n    const recorder = new MediaRecorder(stream, {\n      mimeType: 'video/webm',\n      videoBitsPerSecond: 100_000_000,\n    });\n    const chunks: BlobPart[] = [];\n\n    recorder.ondataavailable = (event) => chunks.push(event.data);\n    recorder.onstop = () => {\n      const blob = new Blob(chunks, {\n        type: 'video/webm',\n      });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n\n      a.setAttribute('href', url);\n      a.setAttribute('download', 'gradient-texture.webm');\n      a.setAttribute('target', '_blank');\n      a.style.display = 'none';\n\n      document.body.appendChild(a);\n\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    };\n\n    (() => {\n      recorder.start();\n      setTimeout(() => recorder.stop(), p);\n    })();\n  });\n\n  main.appendChild(button);\n}\n"]}