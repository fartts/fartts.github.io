{"version":3,"sources":["../lib/core/math.ts","01-webgl/src/main.ts"],"names":[],"mappings":"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","file":"main.4d90f0d4.js","sourceRoot":"../src/lab","sourcesContent":["export const {\n  abs,\n  acos,\n  atan2,\n  ceil,\n  cos,\n  floor,\n  hypot,\n  max,\n  min,\n  PI: π,\n  pow,\n  random,\n  round,\n  sin,\n  sqrt,\n} = Math;\nexport const ππ = π * 2;\nexport const { isFinite } = Number;\n\n/**\n * ## lerp\n * short for \"linear interpolate\" this function returns a number that is\n * interpolated between `a` and `b` by the ratio provided in `i` (e.g. if `i` is\n * 0 `a` is returned, if `i` is 1 `b` is returned)\n *\n * @export\n * @param {number} v0 the lower bound of the interpolation\n * @param {number} v1 the upper bound of the interpolation\n * @param {number} t the ratio by which to interpolate between `a` and `b`\n * @returns {number} a number that is interpolated between `a` and `b` by the\n * ratio provided in `i`\n */\nexport function lerp(v0: number, v1: number, t: number): number {\n  /**\n   * prefer precise method\n   * @see: https://github.com/mattdesl/lerp/blob/master/index.js\n   * @see: https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\n   */\n  return (1 - t) * v0 + t * v1;\n}\n\n/**\n * ## saw\n * this is a trigonometric function (like Math.sin, or Math.cos), it takes an\n * angle in radians and returns a value between -1 and 1, the \"shape\" of the\n * returned values follows a linear \"sawtooth\" pattern\n *\n * @export\n * @param {number} radians a value in radians (clamped between 0 and ππ)\n * @returns {number} a value between -1 and 1 for entry values between 0 and ππ\n */\nexport function saw(radians: number): number {\n  return (radians % ππ) / π - 1;\n}\n\n/**\n * ## tri\n * this is a trigonometric function (like Math.sin, or Math.cos), it takes an\n * angle in radians and returns a value between -1 and 1, the \"shape\" of the\n * returned values follows a linear \"triangle wave\" pattern\n *\n * @export\n * @param {number} radians a value in radians (clamped between 0 and ππ)\n * @returns {number} a value between -1 and 1 for entry values between 0 and ππ\n */\nexport function tri(radians: number): number {\n  return 1 - 2 * abs(saw(radians));\n}\n\n/**\n * ## toDegrees\n * takes an angle in radians and returns that angle in degrees\n *\n * @param {number} radians an angle, in radians\n * @return {number} that same angle, in degrees\n */\nexport function toDegrees(radians: number): number {\n  return (radians * 180) / π;\n}\n\n/**\n * ## toRadians\n * takes an angle in degrees and returns that angle in radians\n *\n * @param {number} degrees an angle, in degrees\n * @return {number} that same angle, in radians\n */\nexport function toRadians(degrees: number): number {\n  return (degrees * π) / 180;\n}\n","import './main.css';\n\nimport { cos, sin, toRadians } from '../../../lib/core/math';\n\nconst DEV = 'development';\n// const PROD = 'production';\n\nconst canvas = document.querySelector('canvas') as HTMLCanvasElement;\nconst canvasContext = canvas.getContext('webgl', {\n  antialias: false,\n}) as WebGLRenderingContext;\n\nconst scale = 10;\nconst width = canvas.clientWidth / scale;\nconst height = canvas.clientHeight / scale;\n// const centerX = width / 2;\n// const centerY = height / 2;\n\ncanvas.width = width;\ncanvas.height = height;\ncanvasContext.clearColor(1, 1, 1, 1);\n\nenum WebGLShaderType {\n  Vertex = canvasContext.VERTEX_SHADER,\n  Fragment = canvasContext.FRAGMENT_SHADER,\n}\n\nfunction makeShader(\n  context: WebGLRenderingContext,\n  type: WebGLShaderType,\n  source: string,\n): WebGLShader {\n  const shader = context.createShader(type) as WebGLShader;\n\n  context.shaderSource(shader, source);\n  context.compileShader(shader);\n\n  if (process.env.NODE_ENV === DEV) {\n    const compileSuccess = context.getShaderParameter(\n      shader,\n      context.COMPILE_STATUS,\n    );\n\n    if (!compileSuccess) {\n      context.deleteShader(shader);\n\n      throw new Error(\n        `shader (${shader}) failed to compile:\\n${context.getShaderInfoLog(\n          shader,\n        )}`,\n      );\n    }\n  }\n\n  return shader;\n}\n\nfunction makeProgram(\n  context: WebGLRenderingContext,\n  vertexShader: WebGLShader,\n  fragmentShader: WebGLShader,\n): WebGLProgram {\n  const program = context.createProgram() as WebGLProgram;\n\n  context.attachShader(program, vertexShader);\n  context.attachShader(program, fragmentShader);\n\n  context.linkProgram(program);\n\n  if (process.env.NODE_ENV === DEV) {\n    const linkSuccess = context.getProgramParameter(\n      program,\n      context.LINK_STATUS,\n    );\n\n    if (!linkSuccess) {\n      context.deleteProgram(program);\n\n      throw new Error(\n        `program (${program}) failed to compile:\\n${context.getShaderInfoLog(\n          program,\n        )}`,\n      );\n    }\n  }\n\n  return program;\n}\n\nconst vertShader = makeShader(\n  canvasContext,\n  WebGLShaderType.Vertex,\n  `\\\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nattribute vec4 a_position;\nvarying vec4 v_color;\n\nvoid main() {\n  gl_Position = a_position;\n  v_color = gl_Position * 0.5 + 0.5;\n}\n`,\n);\n\nconst fragShader = makeShader(\n  canvasContext,\n  WebGLShaderType.Fragment,\n  `\\\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvarying vec4 v_color;\n\nvoid main() {\n\n\tgl_FragColor = vec4(v_color.xy, 1.0, 1.0);\n}\n`,\n);\n\nconst prog = makeProgram(canvasContext, vertShader, fragShader);\nconst aPosition = canvasContext.getAttribLocation(prog, 'a_position');\nconst buffer = canvasContext.createBuffer();\n\ncanvasContext.viewport(0, 0, width, height);\ncanvasContext.useProgram(prog);\n\nlet a = 0;\n\nfunction draw(t: number) {\n  requestAnimationFrame(draw);\n\n  a = (a + 1) % 360;\n  const x = sin(toRadians(a));\n  const y = cos(toRadians(a));\n\n  canvasContext.clear(canvasContext.COLOR_BUFFER_BIT);\n\n  canvasContext.bindBuffer(canvasContext.ARRAY_BUFFER, buffer);\n  canvasContext.bufferData(\n    canvasContext.ARRAY_BUFFER,\n    // prettier-ignore\n    new Float32Array([\n      -0.4 + (x * 0.4), -0.6 + (y * 0.3),\n       0.4 + (x * 0.3), -0.4 + (y * 0.4),\n      -0.1 + (x * 0.2),  0.7 + (y * 0.2),\n    ]),\n    canvasContext.DYNAMIC_DRAW,\n  );\n\n  canvasContext.enableVertexAttribArray(aPosition);\n  canvasContext.bindBuffer(canvasContext.ARRAY_BUFFER, buffer);\n  canvasContext.vertexAttribPointer(\n    aPosition,\n    2,\n    canvasContext.FLOAT,\n    false,\n    0,\n    0,\n  );\n\n  canvasContext.drawArrays(canvasContext.TRIANGLES, 0, 3);\n}\n\nrequestAnimationFrame(draw);\n"]}