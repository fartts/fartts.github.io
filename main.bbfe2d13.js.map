{"version":3,"sources":["../lib/core/math.ts","02-resizing/src/shader.frag","02-resizing/src/shader.vert","02-resizing/src/main.ts"],"names":["module","exports"],"mappings":";;;;;AA0FC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,KAAA,EAAA,QAAA,IAAA,EAAA,QAAA,IAAA,EAAA,QAAA,UAAA,EAAA,QAAA,UAAA,EAAA,QAAA,SAAA,QAAA,GAAA,QAAA,KAAA,QAAA,IAAA,QAAA,MAAA,QAAA,OAAA,QAAA,IAAA,QAAA,EAAA,QAAA,IAAA,QAAA,IAAA,QAAA,MAAA,QAAA,MAAA,QAAA,IAAA,QAAA,KAAA,QAAA,MAAA,QAAA,KAAA,QAAA,SAAA,EA1FM,MAAM,IACX,EADW,KAEX,EAFW,MAGX,EAHW,KAIX,EAJW,IAKX,EALW,MAMX,EANW,MAOX,EAPW,IAQX,EARW,IASX,EACA,GAAI,EAVO,IAWX,EAXW,OAYX,EAZW,MAaX,EAbW,IAcX,EAdW,KAeX,GACE,KA0EH,QAAA,KAAA,EAAA,QAAA,IAAA,EAAA,QAAA,MAAA,EAAA,QAAA,OAAA,EAAA,QAAA,IAAA,EAAA,QAAA,EAAA,EAAA,QAAA,IAAA,EAAA,QAAA,IAAA,EAAA,QAAA,MAAA,EAAA,QAAA,MAAA,EAAA,QAAA,IAAA,EAAA,QAAA,KAAA,EAAA,QAAA,MAAA,EAAA,QAAA,KAAA,EAAA,QAAA,IAAA,EAzEM,MAAM,EAAS,EAAJ,EAyEjB,QAAA,GAAA,EAxEM,MAAM,SAAE,GAAa,OAetB,SAAU,EAAK,EAAY,EAAY,GAMpC,OAAC,EAAI,GAAK,EAAK,EAAI,EAatB,SAAU,EAAI,GACV,OAAA,EAAU,EAAM,EAAI,EAaxB,SAAU,EAAI,GACX,OAAA,EAAI,EAAI,EAAI,EAAI,IAUnB,SAAU,EAAU,GAChB,OAAU,IAAV,EAAiB,EAUrB,SAAU,EAAU,GAChB,OAAA,EAAU,EAAK,IACxB,QAAA,SAAA;;AC1FDA,OAAOC,QAAQ;;ACAfD,OAAOC,QAAQ;;AC+If,aA/IA,QAAA,cAEA,IAAA,EAAA,QAAA,0BAEA,EAAA,EAAA,QAAA,kBACA,EAAA,EAAA,QAAA,kBA0IA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAxIA,MAAM,EAAI,SAAS,cAAc,UAC3B,EAAK,EAAE,WAAW,QAAS,CAC/B,WAAW,IAKb,IAAK,EAKL,SAAS,EACP,EACA,EACA,GAEM,MAAA,EAAS,EAAQ,aAAa,GAsB7B,OApBP,EAAQ,aAAa,EAAQ,GAC7B,EAAQ,cAAc,GAmBf,EAGT,SAAS,EACP,EACA,EACA,GAEM,MAAA,EAAU,EAAQ,gBAwBjB,OAtBP,EAAQ,aAAa,EAAS,GAC9B,EAAQ,aAAa,EAAS,GAE9B,EAAQ,YAAY,GAmBb,EAlET,EAAG,WAAW,EAAG,EAAG,EAAG,GAEvB,SAAK,GACH,EAAA,EAAA,OAAS,EAAG,eAAa,SACzB,EAAA,EAAA,SAAW,EAAG,iBAAe,WAF/B,CAAK,IAAA,EAAe,KAmEpB,MAAM,EAAa,EAAW,EAAI,EAAgB,OAAQ,EAA7B,SACvB,EAAa,EAAW,EAAI,EAAgB,SAAU,EAA/B,SACvB,EAAO,EAAY,EAAI,EAAY,GAEnC,EAAY,EAAG,kBAAkB,EAAM,cACvC,EAAS,EAAG,eAElB,IAAI,EAAI,EACJ,GAAY,EAEhB,SAAS,IAGH,GAFJ,sBAAsB,GAElB,EAAW,CACP,MAAE,YAAa,EAAQ,WAAY,GAAU,OAE7C,EAAQ,GAEd,EAAE,MAAQ,EAAQ,EAClB,EAAE,OAAS,EAAS,EACpB,EAAG,SAAS,EAAG,EAAG,EAAE,MAAO,EAAE,QAE7B,EAAE,MAAM,SAAW,MACnB,EAAE,MAAM,UAAY,MAEpB,GAAY,EAGd,GAAK,EAAI,GAAK,IACR,MAAA,GAAI,EAAI,EAAA,MAAA,EAAU,EAAA,WAAA,IAClB,GAAI,EAAI,EAAA,MAAA,EAAU,EAAA,WAAA,IAExB,EAAG,MAAM,EAAG,kBAEZ,EAAG,WAAW,GAEd,EAAG,WAAW,EAAG,aAAc,GAC/B,EAAG,WACD,EAAG,aAEC,IAAA,aAAa,CACd,GAAW,GAAJ,EAAW,GAAW,GAAJ,EACd,GAAJ,EAAP,GAAkB,GAAW,GAAJ,EACzB,GAAW,GAAJ,EAAsB,GAAJ,EAAP,KAErB,EAAG,cAGL,EAAG,wBAAwB,GAC3B,EAAG,WAAW,EAAG,aAAc,GAC/B,EAAG,oBAAoB,EAAW,EAAG,EAAG,OAAO,EAAO,EAAG,GAEzD,EAAG,WAAW,EAAG,UAAW,EAAG,GAGjC,SAAS,IACP,GAAY,EAGd,OAAO,iBAAiB,SAAU,GAClC,OAAO,cAAc,IAAI,MAAM,WAE/B,sBAAsB","file":"main.bbfe2d13.js","sourceRoot":"../src/lab","sourcesContent":["export const {\n  abs,\n  acos,\n  atan2,\n  ceil,\n  cos,\n  floor,\n  hypot,\n  max,\n  min,\n  PI: π,\n  pow,\n  random,\n  round,\n  sin,\n  sqrt,\n} = Math;\nexport const ππ = π * 2;\nexport const { isFinite } = Number;\n\n/**\n * ## lerp\n * short for \"linear interpolate\" this function returns a number that is\n * interpolated between `a` and `b` by the ratio provided in `i` (e.g. if `i` is\n * 0 `a` is returned, if `i` is 1 `b` is returned)\n *\n * @export\n * @param {number} v0 the lower bound of the interpolation\n * @param {number} v1 the upper bound of the interpolation\n * @param {number} t the ratio by which to interpolate between `a` and `b`\n * @returns {number} a number that is interpolated between `a` and `b` by the\n * ratio provided in `i`\n */\nexport function lerp(v0: number, v1: number, t: number): number {\n  /**\n   * prefer precise method\n   * @see: https://github.com/mattdesl/lerp/blob/master/index.js\n   * @see: https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\n   */\n  return (1 - t) * v0 + t * v1;\n}\n\n/**\n * ## saw\n * this is a trigonometric function (like Math.sin, or Math.cos), it takes an\n * angle in radians and returns a value between -1 and 1, the \"shape\" of the\n * returned values follows a linear \"sawtooth\" pattern\n *\n * @export\n * @param {number} radians a value in radians (clamped between 0 and ππ)\n * @returns {number} a value between -1 and 1 for entry values between 0 and ππ\n */\nexport function saw(radians: number): number {\n  return (radians % ππ) / π - 1;\n}\n\n/**\n * ## tri\n * this is a trigonometric function (like Math.sin, or Math.cos), it takes an\n * angle in radians and returns a value between -1 and 1, the \"shape\" of the\n * returned values follows a linear \"triangle wave\" pattern\n *\n * @export\n * @param {number} radians a value in radians (clamped between 0 and ππ)\n * @returns {number} a value between -1 and 1 for entry values between 0 and ππ\n */\nexport function tri(radians: number): number {\n  return 1 - 2 * abs(saw(radians));\n}\n\n/**\n * ## toDegrees\n * takes an angle in radians and returns that angle in degrees\n *\n * @param {number} radians an angle, in radians\n * @return {number} that same angle, in degrees\n */\nexport function toDegrees(radians: number): number {\n  return (radians * 180) / π;\n}\n\n/**\n * ## toRadians\n * takes an angle in degrees and returns that angle in radians\n *\n * @param {number} degrees an angle, in degrees\n * @return {number} that same angle, in radians\n */\nexport function toRadians(degrees: number): number {\n  return (degrees * π) / 180;\n}\n","module.exports=\"#ifdef GL_ES\\nprecision mediump float;\\n#define GLSLIFY 1\\n#endif\\n\\nvarying vec4 v_color;\\n\\nvoid main() {\\n\\tgl_FragColor = vec4(1.0, v_color.xy, 1.0);\\n}\\n\";","module.exports=\"#ifdef GL_ES\\nprecision mediump float;\\n#define GLSLIFY 1\\n#endif\\n\\nattribute vec4 a_position;\\nvarying vec4 v_color;\\n\\nvoid main() {\\n  gl_Position = a_position;\\n  v_color = gl_Position * 0.5 + 0.5;\\n}\\n\";","import './main.css';\n\nimport { cos, sin, toRadians } from '../../../lib/core/math';\n\nimport frag from './shader.frag';\nimport vert from './shader.vert';\n\nconst c = document.querySelector('canvas') as HTMLCanvasElement;\nconst gl = c.getContext('webgl', {\n  antialias: false,\n}) as WebGLRenderingContext;\n\ngl.clearColor(0, 0, 0, 1);\n\nenum WebGLShaderType {\n  Vertex = gl.VERTEX_SHADER,\n  Fragment = gl.FRAGMENT_SHADER,\n}\n\nfunction makeShader(\n  context: WebGLRenderingContext,\n  type: WebGLShaderType,\n  source: string,\n): WebGLShader {\n  const shader = context.createShader(type) as WebGLShader;\n\n  context.shaderSource(shader, source);\n  context.compileShader(shader);\n\n  if (process.env.NODE_ENV === 'development') {\n    const compileSuccess = context.getShaderParameter(\n      shader,\n      context.COMPILE_STATUS,\n    );\n\n    if (!compileSuccess) {\n      context.deleteShader(shader);\n\n      throw new Error(\n        `shader (${shader}) failed to compile:\\n${context.getShaderInfoLog(\n          shader,\n        )}`,\n      );\n    }\n  }\n\n  return shader;\n}\n\nfunction makeProgram(\n  context: WebGLRenderingContext,\n  vertexShader: WebGLShader,\n  fragmentShader: WebGLShader,\n): WebGLProgram {\n  const program = context.createProgram() as WebGLProgram;\n\n  context.attachShader(program, vertexShader);\n  context.attachShader(program, fragmentShader);\n\n  context.linkProgram(program);\n\n  if (process.env.NODE_ENV === 'development') {\n    const linkSuccess = context.getProgramParameter(\n      program,\n      context.LINK_STATUS,\n    );\n\n    if (!linkSuccess) {\n      context.deleteProgram(program);\n\n      throw new Error(\n        `program (${program}) failed to link:\\n${context.getProgramInfoLog(\n          program,\n        )}`,\n      );\n    }\n  }\n\n  return program;\n}\n\nconst vertShader = makeShader(gl, WebGLShaderType.Vertex, vert);\nconst fragShader = makeShader(gl, WebGLShaderType.Fragment, frag);\nconst prog = makeProgram(gl, vertShader, fragShader);\n\nconst aPosition = gl.getAttribLocation(prog, 'a_position');\nconst buffer = gl.createBuffer();\n\nlet a = 0;\nlet didResize = false;\n\nfunction draw(/* t: number */) {\n  requestAnimationFrame(draw);\n\n  if (didResize) {\n    const { innerHeight: height, innerWidth: width } = window;\n\n    const scale = 0.1;\n\n    c.width = width * scale;\n    c.height = height * scale;\n    gl.viewport(0, 0, c.width, c.height);\n\n    c.style.width = `${width}px`;\n    c.style.height = `${height}px`;\n\n    didResize = false;\n  }\n\n  a = (a + 1) % 360;\n  const x = sin(toRadians(a));\n  const y = cos(toRadians(a));\n\n  gl.clear(gl.COLOR_BUFFER_BIT);\n\n  gl.useProgram(prog);\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferData(\n    gl.ARRAY_BUFFER,\n    // prettier-ignore\n    new Float32Array([\n       0.4 + (x * 0.4),  0.6 + (y * 0.3),\n      -0.4 + (x * 0.3),  0.4 + (y * 0.4),\n       0.1 + (x * 0.2), -0.7 + (y * 0.2),\n    ]),\n    gl.DYNAMIC_DRAW,\n  );\n\n  gl.enableVertexAttribArray(aPosition);\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n\n  gl.drawArrays(gl.TRIANGLES, 0, 3);\n}\n\nfunction onResize(/* event: Event */): void {\n  didResize = true;\n}\n\nwindow.addEventListener('resize', onResize);\nwindow.dispatchEvent(new Event('resize'));\n\nrequestAnimationFrame(draw);\n"]}