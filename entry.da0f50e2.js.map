{"version":3,"sources":["../lib/core/dom.ts","../lib/core/math.ts","../lib/core/wave.ts","16-functional/src/events.ts","16-functional/src/resize.ts","16-functional/src/entry.ts"],"names":[],"mappings":"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","file":"entry.da0f50e2.js","sourceRoot":"../src/lab","sourcesContent":["export const {\n  requestAnimationFrame: rAF,\n  cancelAnimationFrame: cAF,\n  devicePixelRatio: dpr,\n} = window;\n\nexport function el<T extends Element>(selectors: string): T {\n  const element = document.querySelector<T>(selectors);\n\n  if (!element) {\n    throw new Error(`Couldn't get \"${selectors}\" element`);\n  }\n\n  return element;\n}\n\ntype Listener<T extends Event> = (event: T) => void;\n\nexport function on<T extends Event>(type: string, listener: Listener<T>): void {\n  return window.addEventListener(type, listener as EventListener);\n}\n\nexport function off<T extends Event>(\n  type: string,\n  listener: Listener<T>,\n): void {\n  return window.removeEventListener(type, listener as EventListener);\n}\n","export const {\n  abs,\n  acos,\n  atan2,\n  ceil,\n  cos,\n  floor,\n  hypot,\n  max,\n  min,\n  PI: π,\n  pow,\n  random,\n  round,\n  sin,\n  sqrt,\n} = Math;\nexport const ππ = π * 2;\nexport const { isFinite } = Number;\n\n/**\n * ## lerp\n * short for \"linear interpolate\" this function returns a number that is\n * interpolated between `a` and `b` by the ratio provided in `i` (e.g. if `i` is\n * 0 `a` is returned, if `i` is 1 `b` is returned)\n *\n * @export\n * @param {number} v0 the lower bound of the interpolation\n * @param {number} v1 the upper bound of the interpolation\n * @param {number} t the ratio by which to interpolate between `a` and `b`\n * @returns {number} a number that is interpolated between `a` and `b` by the\n * ratio provided in `i`\n */\nexport function lerp(v0: number, v1: number, t: number): number {\n  /**\n   * prefer precise method\n   * @see: https://github.com/mattdesl/lerp/blob/master/index.js\n   * @see: https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\n   */\n  return (1 - t) * v0 + t * v1;\n}\n\n/**\n * ## saw\n * this is a trigonometric function (like Math.sin, or Math.cos), it takes an\n * angle in radians and returns a value between -1 and 1, the \"shape\" of the\n * returned values follows a linear \"sawtooth\" pattern\n *\n * @export\n * @param {number} radians a value in radians (clamped between 0 and ππ)\n * @returns {number} a value between -1 and 1 for entry values between 0 and ππ\n */\nexport function saw(radians: number): number {\n  return (radians % ππ) / π - 1;\n}\n\n/**\n * ## tri\n * this is a trigonometric function (like Math.sin, or Math.cos), it takes an\n * angle in radians and returns a value between -1 and 1, the \"shape\" of the\n * returned values follows a linear \"triangle wave\" pattern\n *\n * @export\n * @param {number} radians a value in radians (clamped between 0 and ππ)\n * @returns {number} a value between -1 and 1 for entry values between 0 and ππ\n */\nexport function tri(radians: number): number {\n  return 1 - 2 * abs(saw(radians));\n}\n\n/**\n * ## toDegrees\n * takes an angle in radians and returns that angle in degrees\n *\n * @param {number} radians an angle, in radians\n * @return {number} that same angle, in degrees\n */\nexport function toDegrees(radians: number): number {\n  return (radians * 180) / π;\n}\n\n/**\n * ## toRadians\n * takes an angle in degrees and returns that angle in radians\n *\n * @param {number} degrees an angle, in degrees\n * @return {number} that same angle, in radians\n */\nexport function toRadians(degrees: number): number {\n  return (degrees * π) / 180;\n}\n","import { cos, saw, sin, tri, ππ } from './math';\n\nexport type TrigFunction = (radians: number) => number;\nexport type WaveFunction = (timestamp: number) => number;\n\n/**\n * ## wave\n * this utility function uses the provided trigonometric function to create a\n * wave function that takes a timestamp in milliseconds (optionally offset by\n * `o`) and that returns a value between `min` and `max` for the period `p`\n *\n * @export\n * @param {TrigFunction} fn the function to generate the wave (takes a value in\n * radians and returns a value between -1 and 1 at some interval)\n * @param {number} [p=1000] the period for this wave (in milliseconds)\n * @param {*} [min=-1] the minimum value for the generated wave\n * @param {number} [max=1] the maximum value for the generated wave\n * @param {number} [o=0] an optional offset (in milliseconds) at which to start\n * the wave\n * @returns {WaveFunction} a wave function that takes a timestamp in\n * milliseconds (optionally offset by `o`) and returns a value between `min` and\n * `max` for the period `p`\n */\nexport function wave(\n  fn: TrigFunction,\n  p = 1000,\n  min = -1,\n  max = 1,\n  o = 0,\n): WaveFunction {\n  /**\n   * peak amplitude (not peak-to-peak amplitude)\n   * @see https://en.wikipedia.org/wiki/Amplitude\n   */\n  const amp = (max - min) / 2;\n\n  /**\n   * radians per period (angular frequency)\n   * @see https://en.wikipedia.org/wiki/Angular_frequency\n   */\n  const rpp = ππ / p;\n\n  return (t: number) => {\n    const ots = o + t; // offset timestamp\n    return amp * (1 + fn(ots * rpp)) + min;\n  };\n}\n\ntype CurriedWaveFunction = (\n  p?: number,\n  min?: number,\n  max?: number,\n  o?: number,\n) => WaveFunction;\n\nexport const [cosWave, sawWave, sinWave, triWave]: CurriedWaveFunction[] = [\n  (p = 1000, min = -1, max = 1, o = 0) => wave(cos, p, min, max, o),\n  (p = 1000, min = -1, max = 1, o = 0) => wave(saw, p, min, max, o),\n  (p = 1000, min = -1, max = 1, o = 0) => wave(sin, p, min, max, o),\n  (p = 1000, min = -1, max = 1, o = 0) => wave(tri, p, min, max, o),\n];\n","type Listener<K extends keyof HTMLElementEventMap> = (\n  event: HTMLElementEventMap[K],\n) => void;\n\nexport function on<T extends EventTarget, U extends keyof HTMLElementEventMap>(\n  target: T,\n  forEvent: U,\n  listener: Listener<U>,\n  options: boolean | AddEventListenerOptions = false,\n) {\n  target.addEventListener(forEvent, listener as EventListener, options);\n}\n\nexport function off<T extends EventTarget, U extends keyof HTMLElementEventMap>(\n  target: T,\n  forEvent: U,\n  listener: Listener<U>,\n  options: boolean | AddEventListenerOptions = false,\n) {\n  target.removeEventListener(forEvent, listener as EventListener, options);\n}\n","interface ResizeableElement extends HTMLElement {\n  width: number;\n  height: number;\n}\n\nconst { max } = Math;\nconst { devicePixelRatio: dpr } = window;\n\nfunction nearest(multipleOf = 1, startingAt = 0) {\n  return startingAt % multipleOf !== 0\n    ? startingAt + (multipleOf - (startingAt % multipleOf))\n    : startingAt;\n}\n\nexport function resize(\n  container: HTMLElement,\n  target: ResizeableElement,\n  scale = 1,\n) {\n  const { clientHeight: h, clientWidth: w } = container;\n\n  const width = nearest(scale, w);\n  const height = nearest(scale, h);\n\n  target.width = (width * dpr) / scale;\n  target.height = (height * dpr) / scale;\n\n  target.style.transform = `scale(${max(w / target.width, h / target.height)})`;\n}\n","import './style.css';\n\nimport { el, rAF } from '../../../lib/core/dom';\nimport {\n  π,\n  ππ,\n  max,\n  sin,\n  cos,\n  random,\n  atan2,\n  toDegrees,\n  min,\n  abs,\n} from '../../../lib/core/math';\nimport { sinWave, cosWave } from '../../../lib/core/wave';\n\nimport { on } from './events';\nimport { resize } from './resize';\n\nconst main = el<HTMLElement>('main');\nconst canvas = el<HTMLCanvasElement>('canvas');\nconst context = canvas.getContext('2d');\n\nif (!context) {\n  throw new Error(\"Couldn't get a `CanvasRenderingContext2D`\");\n}\n\nlet shouldResize = true;\n\non(window, 'resize', () => {\n  shouldResize = true;\n});\n\nconst getCanvasScale = () => {\n  const { clientWidth: mw, clientHeight: mh } = main;\n  const { width: cw, height: ch } = canvas;\n\n  return max(mw / cw, mh / ch);\n};\n\nlet canvasScale = getCanvasScale();\n\nconst pixelScale = 12;\nconst frameTime = 1_000 / 60;\n\nlet firstTime: number;\nlet previousTime: number;\nlet overTime: number;\n\n// append\n// select\n// update\n// remove\n\ntype Vector = {\n  x: number;\n  y: number;\n};\n\ntype Particle = {\n  cpos: Vector;\n  ppos: Vector;\n};\n\ntype Constraint = [Particle, Particle];\n\nconst particles: Particle[] = [];\nconst constraints: Constraint[] = [];\n\nconst step = 10;\nconst stepCoef = 1 / step;\n\nconst drag = 0.9;\nconst grav: Vector = {\n  x: 0,\n  y: 0.1,\n};\n\nconst length = 15;\nconst stiffness = 0.9;\n\nlet xw = sinWave(750, canvas.width / 2 - 14, canvas.width / 2 + 16);\nlet yw = cosWave(\n  750,\n  canvas.height / 2 + length * 2,\n  canvas.height / 2 + length * 2 - 10,\n);\n\nconst rotate: (v: Vector, o: Vector, a: number) => Vector = (v, o, a) => ({\n  x: (v.x - o.x) * cos(a) - (v.y - o.y) * sin(a) + o.x,\n  y: (v.x - o.x) * sin(a) + (v.y - o.y) * cos(a) + o.y,\n});\n\nconst angula: (a: Particle, b: Particle, c: Particle) => void = (a, b, c) => {\n  const x1 = a.cpos.x - b.cpos.x;\n  const y1 = a.cpos.y - b.cpos.y;\n\n  const x2 = c.cpos.x - b.cpos.x;\n  const y2 = c.cpos.y - b.cpos.y;\n\n  const angle = (atan2(x1 * y2 - y1 * x2, x1 * x2 + y1 * y2) + ππ) % ππ;\n\n  if (angle < π * 0.8 || ππ * 0.8 < angle) {\n    const diff = min(abs(angle - π), abs(ππ * 0.9 - angle)) * stiffness;\n\n    a.cpos = rotate(a.cpos, b.cpos, diff);\n    c.cpos = rotate(c.cpos, b.cpos, -diff);\n\n    b.cpos = rotate(b.cpos, a.cpos, diff);\n    b.cpos = rotate(b.cpos, c.cpos, -diff);\n  }\n};\n\nconst update = (t: number, dt: number) => {\n  particles.forEach((p, i) => {\n    const v: Vector = {\n      x: (p.cpos.x - p.ppos.x) * drag,\n      y: (p.cpos.y - p.ppos.y) * drag,\n    };\n\n    p.ppos.x = p.cpos.x;\n    p.ppos.y = p.cpos.y;\n\n    p.cpos.x += grav.x;\n    p.cpos.y += grav.y;\n\n    p.cpos.x += v.x;\n    p.cpos.y += v.y;\n  });\n\n  const [a, b, c, d, e, f] = particles;\n\n  if (a) {\n    a.cpos.x = canvas.width / 2;\n    a.cpos.y = canvas.height / 2;\n  }\n\n  if (c) {\n    c.cpos.x = xw(t);\n    c.cpos.y = yw(t);\n  }\n\n  if (d) {\n    d.cpos.x = canvas.width / 2 + 5;\n    d.cpos.y = canvas.height / 2;\n  }\n\n  if (f) {\n    f.cpos.x = xw(t + 375) + 5;\n    f.cpos.y = yw(t + 375);\n  }\n\n  for (let i = 0; i < step; ++i) {\n    constraints.forEach(([g, h]) => {\n      const n: Vector = {\n        x: g.cpos.x - h.cpos.x,\n        y: g.cpos.y - h.cpos.y,\n      };\n\n      const m = n.x * n.x + n.y * n.y;\n      const s = ((length * length - m) / m) * stiffness * stepCoef;\n      n.x *= s;\n      n.y *= s;\n\n      g.cpos.x += n.x;\n      g.cpos.y += n.y;\n\n      h.cpos.x -= n.x;\n      h.cpos.y -= n.y;\n    });\n  }\n\n  angula(a, b, c);\n  angula(d, e, f);\n};\n\nconst render = (ctx: CanvasRenderingContext2D) => {\n  ctx.lineWidth = 1;\n\n  particles.forEach(({ cpos }, i) => {\n    ctx.strokeStyle = i < 3 ? 'rgb(255, 0, 0, 0.5)' : 'rgb(0, 0, 255, 0.5)';\n\n    ctx.beginPath();\n    ctx.ellipse(cpos.x, cpos.y, 5, 5, 0, 0, ππ);\n    ctx.stroke();\n  });\n\n  constraints.forEach(([a, b], i) => {\n    ctx.strokeStyle = i < 2 ? 'rgb(255, 0, 0, 0.5)' : 'rgb(0, 0, 255, 0.5)';\n\n    ctx.save();\n    ctx.translate(a.cpos.x, a.cpos.y);\n    ctx.rotate(atan2(b.cpos.y - a.cpos.y, b.cpos.x - a.cpos.x));\n\n    ctx.beginPath();\n    ctx.moveTo(0, 4);\n    ctx.lineTo(length, 4);\n    ctx.moveTo(0, -4);\n    ctx.lineTo(length, -4);\n    ctx.stroke();\n\n    ctx.restore();\n  });\n};\n\n// on(canvas, 'mousemove', ({ clientX, clientY }) => {\n//   if (!particles[5]) {\n//     return;\n//   }\n\n//   particles[5].cpos.x = particles[5].ppos.x = clientX / canvasScale;\n//   particles[5].cpos.y = particles[5].ppos.y = clientY / canvasScale;\n// });\n\nconst leg: (x: number, y: number) => void = (x, y) => {\n  const a: Particle = {\n    cpos: { x, y },\n    ppos: { x, y },\n  };\n\n  const b: Particle = {\n    cpos: { x, y: y + length },\n    ppos: { x, y: y + length },\n  };\n\n  const c: Particle = {\n    cpos: { x, y: y + length * 2 },\n    ppos: { x, y: y + length * 2 },\n  };\n\n  particles.push(a);\n  particles.push(b);\n  particles.push(c);\n\n  constraints.push([a, b]);\n  constraints.push([b, c]);\n};\n\nconst tick = (time: DOMHighResTimeStamp) => {\n  rAF(tick);\n\n  firstTime || (firstTime = time); // tslint:disable-line:no-unused-expression\n\n  if (shouldResize) {\n    resize(main, canvas, pixelScale);\n    shouldResize = false;\n\n    canvasScale = getCanvasScale();\n    xw = sinWave(750, canvas.width / 2 - 14, canvas.width / 2 + 16);\n    yw = cosWave(\n      750,\n      canvas.height / 2 + length * 2,\n      canvas.height / 2 + length * 2 - 10,\n    );\n\n    firstTime = time;\n    previousTime = 0;\n    overTime = 0;\n  }\n\n  const normalTime = time - firstTime;\n  const deltaTime = normalTime - previousTime;\n  const { width: w, height: h } = canvas;\n\n  overTime += deltaTime;\n\n  if (normalTime === 0) {\n    // first frame, do setup stuff here\n    particles.length = 0;\n    constraints.length = 0;\n\n    leg(w / 2, h / 2);\n    leg(w / 2 + 5, h / 2);\n  }\n\n  // every subsequent frame\n  while (overTime >= frameTime) {\n    update(normalTime, frameTime);\n    overTime -= frameTime;\n  }\n\n  context.clearRect(0, 0, w, h);\n  render(context);\n\n  // context.fillStyle = 'red';\n  // for (let i = 0; i < 1_000; i += frameTime * 10) {\n  //   context.beginPath();\n  //   context.ellipse(xw(normalTime + i), yw(normalTime + i), 1, 1, 0, 0, ππ);\n  //   context.fill();\n  // }\n\n  previousTime = normalTime;\n};\n\nrAF(tick);\n"]}